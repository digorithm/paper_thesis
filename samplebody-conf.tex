\section{Introduction}

The industrial adoption of microservices has led to increasingly complex configuration schemes that are commonly fine-tuned by engineers manually. Ganek and Corbi (2003) discussed the need for autonomic computing to handle the complexity of managing software systems. They noted that managing complex systems has become too costly, prone to error, and labor-intensive, because people under such pressure make mistakes, increasing the potential of system outages with a concurrent impact on business \cite{ganek_dawning_2003}. This has driven many researchers to study self-adaptive systems over the years \cite{porter_rex:_2016, andrew_pavlo_self-driving_2017, salehie_self-adaptive_2009, ganapathi_predicting_2009, herbst_self-adaptive_2014, faniyi_architecting_2014}; however, the software industry still lacks practical tools to provide self-adaptation mechanisms to their systems. Thus, most of the configuring and tuning of the systems are performed manually, often in run-time, which is known to be a very time consuming and risky practice \cite{ganek_dawning_2003, using_prob_reasoning_automate_software_tuning, de_lemos_software_2013}.

% Move Paul Horn stuff to Related Work

In this work we present an accessible tool to support the development of self-adaptive systems. One of our main goals is to provide such support requiring minimal effort from the engineers. In return our tool uses ideas from system observability, machine learning, and control theory to automatically asses the system's environment, predict the impact of changes that could potentially improve the system, and automatically make these changes.

Our approach consists of providing an API to collect relevant systems' metrics and configurations that represent the state of the system in relation to time. Then we map Service Level Objectives (SLOs) to some of these metrics, feed these into a machine learning component that is concurrently re-learning the model while analyzing and predicting the workload and the optimal configurations. As a result it provides adaptation plans that can be both 1) automatically executed, allowing the system to have self-adaptive capabilities, and 2) interpretable, allowing engineers to know the impact of a change in the configuration space before it is deployed.

In summary, our main contributions are:

\begin{itemize}
  \item We provide a methodology to assist the development and evolution of self-adaptive systems, regardless of the presence of self-adaptability in the system's foundations. Such methodology is encapsulated in the tool described in this work.
  \item We show how to make the minimal necessary changes to the system, and how to model SLAs/SLOs and map them to the optimization objectives. These tasks being the development cost incurred by the engineers.
  \item We present a case study that shows how a software system's response time, throughput, and usage were improved by $A\%$, $B\%$, and $C\%$ respectively after integrating a self-adaptation mechanism.
\end{itemize}

The rest of this paper is structure as follows: in Section 2 we discuss some past research in the space of self-adaptive systems and provide fundamental background. In Section 3 we outline our approach, explaining the blend of ideas from different fields. In Section 4 we describe internal details and design decisions of our implementation. In Section 5 we present our case study followed by a discussion and future directions in Section 6. Finally, we conclude our findings with Section 7.

%
% here we reorganize these characteristics into the following terminology:

% \begin{itemize}
%   \item \textbf{Self-Awareness}: an autonomic system needs to know itself;
%   \item \textbf{Self-configuring}: an autonomic system must configure and reconfigure itself under varying and unpredictable conditions;
%   \item \textbf{Self-optimization}: an autonomic system never settles for the status quo, it always looks for ways to optimize its workings, it will anticipate the optimized resources needed to meet a user's information needs while keeping its complexity hidden;
%   \item \textbf{Self-healing}: An autonomic system must perform something akin to healing, it must be able to recover from routine and extraordinary events that might cause some parts to malfunction.
% \end{itemize}


% \begin{itemize}
%   \item Use of system observability to collect a sufficiently big time series dataset that represents the state of a system and its components in relation to time;
%   \item Use of Machine Learning applied to time series data to analyze and predict workload and optimal configuration in order to provide adaptation plans;
%   \item Use of Online Learning to provide constant relearning of the model to adapt to different scenarios and requirements;
%   \item Use of Service Level Objectives as a way to define the system's performance goals that will be used by the tool as optimization objectives;
%   \item Use of the concepts in control theory as the central component of this tool, in which it implements a variation of the well known and studies MAPE loop (Monitor, Analyze, Plan, Execute);
%   \item Abstraction of all the concepts above into a tool that can be integrated to compatible systems, including systems that were built without self-adaptation in mind. 
% \end{itemize}

% The rest of the paper is structure as following: 


% I can develop a bit more on this by using this survey's result: According to a recent
% IT resource survey by the Merit Project of Computer Associates International, 1867 respondents grouped the most common causes of outages into four areas of data center operations: systems, networks, database, and applications.
% Most frequently cited outages included:
%- For systems: operational error, user error, third-party software error, internally %developed software problem, inadequate change control, lack of automated processes
%- For networks: performance overload, peak load problems, insufficient bandwidth
%- For database: out of disk space, log file full, performance overload
%- For  applications:  application  error,  inadequate change control, operational %error, nonautomated application exceptions
% A nice point is that these are the problems we're still facing whenever we deal poorly with the complexity of the systems

% It would be nice also to cite IBM autonomic computing initiative

% IBM’s autonomic computing initiative has been outlined broadly. Paul Horn described this “grand challenge” and called for industry-wide collaboration toward developing autonomic computing systems that have characteristics as follows: ● To be autonomic  a system needs to “ know itself ”— and consist of components that also possess a sys- tem identity. ● An autonomic system must con fi gure and recon- fi gure itself under varying and unpredictable con- ditions. ● An autonomic system never settles for the status quo — it always looks for ways to optimize its work- ings. ● An autonomic system must perform something akin to healing — it must be able to recover from routine and extraordinary events that might cause some parts to malfunction. ● A virtual world is no less dangerous than the phys- ical one, so an autonomic computing system must be an expert in self-protection. ● An autonomic computing system knows its envi- ronment and the context surrounding its activity, and acts accordingly. ● An autonomic system cannot exist in a hermetic environment (and must adhere to open standards). ● Perhaps most critical for the user, an autonomic computing system will anticipate the optimized re- sources needed to meet a user ’ s information needs while keeping its complexity hidden.

\section{Related Work}

Maybe related work would be better now instead of putting it in the end, since there are a lot of related work and they are very relevant to this work, it would be nice to upfront point out what has been done and what would be different in this work.

% https://arxiv.org/pdf/1712.01208.pdf cite this paper here as an example of a new trend emerging in industry and academia: substituting heuristics in software with machine learning models, making the algorithms more data-aware.


Also include background here.

\section{Approach}

\subsection{Control theory and self-adaptive systems}

\subsection{System's configuration as an optimization problem}

\subsection{Providing system adaptation with machine learning}

\subsection{Workload simulation}

\subsection{System instrumentation}

\subsection{Machine learning architecture}

\subsubsection{Features and models}

\subsubsection{Online training}

\subsubsection{Achieving self-adapation}

\section{Implementation}

\section{Evaluation}

To guide and evaluate our work, five research questions are used:

\begin{itemize}
  \item \textbf{RQ1:} Can self-adaptation by learned models lead to more stable, faster, and safer software systems?
  \item \textbf{RQ2:} Can self-adaptation by learned models reduce the need for manually configuring and tuning systems?
  \item \textbf{RQ3:} Can our tool be easily integrated in software systems, requiring only small changes to the codebase?
  \item \textbf{RQ4:} Can our tool work with low overhead?
  \item \textbf{RQ5:} Which features are more relevant to predict workload and performance?
\end{itemize}

\textcolor{red}{Challenges with RQ1: should we keep "stable" and "safer"? Faster is easy to quantify, stable and safer is tricky to quantify but it can be reasonably easy to infer given all the performance improvements. Thoughts?}

\textcolor{purple}{Challenges with RQ2: same challenges as in RQ1, do we have to quantify or just inferring less need to configure/tune given that it's being done by the learned model \textit{and} it's performing well/better is enough?}

\textcolor{blue}{Challenges with RQ3: "Easily" sounds subjective and hard to quantify, but I believe it's possible to see that it's not a super complicated task if all it's being asked is to instrument/annotate parts of the code. But then again, I might be very biased.}

\textcolor{brown}{Challenges with RQ5: although it might be interesting, it may not generalize to different scenarios.}

\section{Discussion and future work}

\section{Conclusions}

%\end{document}  % This is where a 'short' article might terminate

\nocite{*}

\begin{acks}

\end{acks} 